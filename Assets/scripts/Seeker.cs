using UnityEngine;
using System.Collections;
//including some .NET for dynamic arrays called List in C#
using System.Collections.Generic;

public class Seeker : MonoBehaviour
{
	public GameObject target  = null;
	// These weights will be exposed in the Inspector window
	public float avoidDist = 30.0f;
	public float seekWt = 10.0f;
	public float avoidWt = 10.0f;
	
	// Each vehicle contains a CharacterController which
	// makes it easier to deal with the relationship between
	// movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController myCharacterController = null;
	
	// the steering component implements the basic steering functions
	private Steering steerer = null;
	
	// movement variables
	private float gravity = 20.0f;
	private Vector3 moveDirection;

	//steering variable
	private Vector3 steeringForce;
	
	//reference to an array of obstacles
	private  GameObject[] obstacles; 

	
	public void Start ()
	{
		//get component reference
		myCharacterController = gameObject.GetComponent<CharacterController> ();
		steerer = gameObject.GetComponent<Steering> ();
		moveDirection = transform.forward;
		obstacles = GameObject.FindGameObjectsWithTag("Obstacle");
	}

	private void ClampSteering ()
	{
		if (steeringForce.magnitude > steerer.maxForce) {
			steeringForce.Normalize ();
            steeringForce *= steerer.maxForce;
		}
	}
	
	// Update is called once per frame
	public void Update ()
	{
		CalcSteeringForce ();
		ClampSteering ();
		
		moveDirection = transform.forward * steerer.Speed;
		// movedirection equals velocity
		//add acceleration
		moveDirection += steeringForce * Time.deltaTime;
		//modified for dt
		//update speed
		steerer.Speed = moveDirection.magnitude;
		if (steerer.Speed != moveDirection.magnitude) {
			moveDirection = moveDirection.normalized * steerer.Speed;
		}
		//orient transform
		if (moveDirection != Vector3.zero)
			transform.forward = moveDirection;
		
		// Apply gravity
		moveDirection.y -= gravity;
		
		// the CharacterController moves us subject to physical constraints
		myCharacterController.Move (moveDirection * Time.deltaTime);
	}


	private void CalcSteeringForce ()
	{
		steeringForce = Vector3.zero;
		steeringForce += seekWt * steerer.seek (target.transform.position);
        for (int i = 0; i < obstacles.Length; i++)
        {
            steeringForce += avoidWt * steerer.AvoidObstacle(obstacles[i], avoidDist);
        }
	}
	
}



